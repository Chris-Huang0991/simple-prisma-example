// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateImageFile {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type ImageFile {
  id: ID!
  url: String!
}

type ImageFileConnection {
  pageInfo: PageInfo!
  edges: [ImageFileEdge]!
  aggregate: AggregateImageFile!
}

input ImageFileCreateInput {
  id: ID
  url: String!
}

input ImageFileCreateOneInput {
  create: ImageFileCreateInput
  connect: ImageFileWhereUniqueInput
}

type ImageFileEdge {
  node: ImageFile!
  cursor: String!
}

enum ImageFileOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
}

type ImageFilePreviousValues {
  id: ID!
  url: String!
}

type ImageFileSubscriptionPayload {
  mutation: MutationType!
  node: ImageFile
  updatedFields: [String!]
  previousValues: ImageFilePreviousValues
}

input ImageFileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageFileWhereInput
  AND: [ImageFileSubscriptionWhereInput!]
  OR: [ImageFileSubscriptionWhereInput!]
  NOT: [ImageFileSubscriptionWhereInput!]
}

input ImageFileUpdateDataInput {
  url: String
}

input ImageFileUpdateInput {
  url: String
}

input ImageFileUpdateManyMutationInput {
  url: String
}

input ImageFileUpdateOneInput {
  create: ImageFileCreateInput
  update: ImageFileUpdateDataInput
  upsert: ImageFileUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ImageFileWhereUniqueInput
}

input ImageFileUpsertNestedInput {
  update: ImageFileUpdateDataInput!
  create: ImageFileCreateInput!
}

input ImageFileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [ImageFileWhereInput!]
  OR: [ImageFileWhereInput!]
  NOT: [ImageFileWhereInput!]
}

input ImageFileWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createImageFile(data: ImageFileCreateInput!): ImageFile!
  updateImageFile(data: ImageFileUpdateInput!, where: ImageFileWhereUniqueInput!): ImageFile
  updateManyImageFiles(data: ImageFileUpdateManyMutationInput!, where: ImageFileWhereInput): BatchPayload!
  upsertImageFile(where: ImageFileWhereUniqueInput!, create: ImageFileCreateInput!, update: ImageFileUpdateInput!): ImageFile!
  deleteImageFile(where: ImageFileWhereUniqueInput!): ImageFile
  deleteManyImageFiles(where: ImageFileWhereInput): BatchPayload!
  createStudent(data: StudentCreateInput!): Student!
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  upsertStudent(where: StudentWhereUniqueInput!, create: StudentCreateInput!, update: StudentUpdateInput!): Student!
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  imageFile(where: ImageFileWhereUniqueInput!): ImageFile
  imageFiles(where: ImageFileWhereInput, orderBy: ImageFileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ImageFile]!
  imageFilesConnection(where: ImageFileWhereInput, orderBy: ImageFileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageFileConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student]!
  studentsConnection(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudentConnection!
  node(id: ID!): Node
}

type Student {
  id: ID!
  photo: ImageFile
}

type StudentConnection {
  pageInfo: PageInfo!
  edges: [StudentEdge]!
  aggregate: AggregateStudent!
}

input StudentCreateInput {
  id: ID
  photo: ImageFileCreateOneInput
}

type StudentEdge {
  node: Student!
  cursor: String!
}

enum StudentOrderByInput {
  id_ASC
  id_DESC
}

type StudentPreviousValues {
  id: ID!
}

type StudentSubscriptionPayload {
  mutation: MutationType!
  node: Student
  updatedFields: [String!]
  previousValues: StudentPreviousValues
}

input StudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudentWhereInput
  AND: [StudentSubscriptionWhereInput!]
  OR: [StudentSubscriptionWhereInput!]
  NOT: [StudentSubscriptionWhereInput!]
}

input StudentUpdateInput {
  photo: ImageFileUpdateOneInput
}

input StudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  photo: ImageFileWhereInput
  AND: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
}

input StudentWhereUniqueInput {
  id: ID
}

type Subscription {
  imageFile(where: ImageFileSubscriptionWhereInput): ImageFileSubscriptionPayload
  student(where: StudentSubscriptionWhereInput): StudentSubscriptionPayload
}
`